import os
import time
import psutil
from collections import defaultdict
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import concurrent.futures  
import threading

THRESHOLD = 10
MAX_THREADS = 4  

class RansomwareFileHandler(FileSystemEventHandler):
    def __init__(self, valid_extensions, executor):
        super().__init__()
        self.file_changes = defaultdict(int)
        self.lock = threading.Lock()
        self.valid_extensions = valid_extensions
        self.observer = None
        self.executor = executor

    def start_observer(self, path):
        self.observer = Observer()
        self.observer.schedule(self, path, recursive=True)
        self.observer.start()

    def stop_observer(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()

    def on_modified(self, event):
        if event.is_directory:
            return
        
        if any(event.src_path.endswith(ext) for ext in self.valid_extensions):
            self.executor.submit(self.process_file_change, event.src_path)

    def process_file_change(self, path):
        with self.lock:
            self.file_changes[path] += 1

class EDR:
    def __init__(self):
        self.suspicious_pids = set()
        self.lock = threading.Lock()
        self.valid_extensions = (".txt", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".pdf", ".jpg", ".png", ".bmp", ".gif", ".mp3", ".mp4")
        self.executor = concurrent.futures.ThreadPoolExecutor(MAX_THREADS)
        self.file_handler = RansomwareFileHandler(self.valid_extensions, self.executor)
        self.start()

    def start(self):
        print('/////////////////////////////////')
        print('---------------------------------')
        print('--------> EDR inciando <---------')
        print('---------------------------------')
        print('')
        print('/////////////////////////////////')
        print('')
        pastas_monitoradas = [
            os.path.expandvars("%USERPROFILE%\\Desktop"),
            os.path.expandvars("%USERPROFILE%\\Documents"),
            os.path.expandvars("%USERPROFILE%\\Downloads")
        ]

        for pasta in pastas_monitoradas:
            self.file_handler.start_observer(pasta)

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            pass

    def start_file_handler_observer(self, paths):
        self.file_handler_observer = Observer()
        for path in paths:
            handler = self.file_handler
            self.file_handler_observer.schedule(handler, path, recursive=True)
            handler.start_observer(path)
        self.file_handler_observer.start()

        print('---------------------------------')
        print('--------> EDR iniciado <---------')
        print('---------------------------------')
        print('/////////////////////////////////')
        print('')

    def monitoramento_pastas(self, paths):
        observers = []

        for path in paths:
            observer = Observer()
            observer.schedule(self.file_handler, path, recursive=True)
            observer.start()
            observers.append(observer)

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            for observer in observers:
                observer.stop()
            for observer in observers:
                observer.join()

    def rodar_detector(self):
        try:
            while True:
                time.sleep(10)
                with self.lock:
                    self.identificar_processos_suspeitos()
        except KeyboardInterrupt:
            pass

    def identificar_processos_suspeitos(self):
        with self.file_handler.lock:
            with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
                for path, mudanca in self.file_handler.file_changes.items():
                    if mudanca >= THRESHOLD:
                        executor.submit(self.processar_arquivo_suspeito, path)

    def identificar_processos_suspeitos2(self):  # Renomeada para evitar conflito
        with self.file_handler.lock:
            for path, mudanca in self.file_handler.file_changes.items():
                if mudanca >= THRESHOLD:
                    for processo in psutil.process_iter(['pid', 'name']):
                        try:
                            processo_info = processo.info
                            pid = processo_info['pid']
                            if self.processo_interagindo_arquivo(pid, path):
                                with self.lock:
                                    self.suspicious_pids.add(pid)
                        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                            pass

    def processo_interagindo_arquivo(self, pid, path_arquivo):
        try:
            processo = psutil.Process(pid)
            abrir_arquivos = processo.open_files()
            for arquivo in abrir_arquivos:
                if path_arquivo == arquivo.path:
                    return True
            return False
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            return False

    def finalizar_processos_suspeitos(self):
        for pid in self.suspicious_pids:
            try:
                process = psutil.Process(pid)
                process.terminate()
                print(f"Processo com PID {pid} finalizado.")
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass

if __name__ == '__main__':
    try:
        edr = EDR()
        edr.start()
    except Exception as e:
        print(f"Erro inesperado: {e}")
